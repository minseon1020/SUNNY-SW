// src/components/MapKorea.jsx
// ëŒ€í•œë¯¼êµ­ ì½”ë¡œí”Œë ˆìŠ¤ ì§€ë„ â€” ì‹œ/ë„ â†’ ì‹œÂ·êµ°Â·êµ¬ ë“œë¦´ë‹¤ìš´ + ì—ë„ˆì§€ íˆíŠ¸ì»¬ëŸ¬(ì „ê¸°/ê°€ìŠ¤ í† ê¸€)

import { useEffect, useMemo, useRef, useState } from "react";
import {
  MapContainer,
  TileLayer,
  GeoJSON,
  Pane,
  useMap,
  useMapEvent,
} from "react-leaflet";
import L from "leaflet";
import centerOfMass from "@turf/center-of-mass";
import "leaflet/dist/leaflet.css";
import "./MapKorea.css";

// í‚¤/ìœ í‹¸ 
const SIDO_CODE_KEYS = ["CTPRVN_CD", "CTPRV_CD", "CTP_CD", "SIDO_CD", "SIG_CD"];
const SIDO_NAME_KEYS = ["CTP_KOR_NM", "SIDO_NM", "CTP_ENG_NM", "CTP_NM"];
const SGG_CODE_KEYS = ["SIG_CD", "SGG_CD", "ADM_DR_CD"];
const SGG_NAME_KEYS = ["SIG_KOR_NM", "SGG_NM", "ADM_DR_NM", "SIG_NM"];
const PARENT_KEYS = ["CTPRVN_CD", "UPPER_CD", "SIDO_CD"];

const pick = (o, keys) => {
  for (const k of keys) {
    if (o && o[k] != null) return o[k];
  }
};

//  ë°ì´í„° ì½”ë“œ ì •ê·œí™” 
// ì‹œêµ°êµ¬ ì½”ë“œ: ê·¸ëƒ¥ 5ìë¦¬ë§Œ ë§ì¶°ì„œ ì‚¬ìš©
const normalizeSggCodeFromData = (countyId) => {
  if (countyId == null) return null;
  return String(countyId).padStart(5, "0").slice(0, 5); // ì˜ˆ: 51110
};
// ë·°í¬íŠ¸/í´ë¨í”„  
const KOREA_BOUNDS = [
  [32.5, 124.0],
  [39.6, 132.5],
];

function ClampToKorea() {
  const map = useMap();
  useEffect(() => {
    map.options.inertia = false;
  }, [map]);
  const clamp = () => {
    if (!map.getBounds().intersects(KOREA_BOUNDS)) {
      map.panInsideBounds(KOREA_BOUNDS, { animate: false });
    }
  };
  useMapEvent("move", clamp);
  useMapEvent("zoom", clamp);
  useMapEvent("moveend", clamp);
  return null;
}

function useFitBounds(geojsonRef, deps = []) {
  const map = useMap();
  useEffect(() => {
    const layer = geojsonRef.current;
    if (!layer) return;
    try {
      const b = layer.getBounds();
      if (b && b.isValid()) {
        const s = Math.max(b.getSouth(), KOREA_BOUNDS[0][0]);
        const w = Math.max(b.getWest(), KOREA_BOUNDS[0][1]);
        const n = Math.min(b.getNorth(), KOREA_BOUNDS[1][0]);
        const e = Math.min(b.getEast(), KOREA_BOUNDS[1][1]);
        map.fitBounds(
          [
            [s, w],
            [n, e],
          ],
          { padding: [24, 24], paddingBottomRight: [24, 80] }
        );
      }
    } catch {}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
}

function FitToLayer({ targetRef, deps }) {
  useFitBounds(targetRef, deps);
  return null;
}

//  ë§ˆìŠ¤í¬ 
const WORLD_RING = [
  [-180, -90],
  [-180, 90],
  [180, 90],
  [180, -90],
  [-180, -90],
];

const ringsFromGeom = (g) =>
  !g
    ? []
    : g.type === "Polygon"
    ? g.coordinates
    : g.type === "MultiPolygon"
    ? g.coordinates.flat()
    : [];

const makeMaskFromSidoFC = (fc) => {
  if (!fc?.features) return null;
  const holes = [];
  for (const f of fc.features) holes.push(...ringsFromGeom(f.geometry));
  return {
    type: "Feature",
    properties: { kind: "mask-korea" },
    geometry: { type: "Polygon", coordinates: [WORLD_RING, ...holes] },
  };
};

const makeMaskFromOneSido = (f) => {
  if (!f?.geometry) return null;
  const holes = ringsFromGeom(f.geometry);
  return {
    type: "Feature",
    properties: { kind: "mask-sido" },
    geometry: { type: "Polygon", coordinates: [WORLD_RING, ...holes] },
  };
};

// ì‹œ/ë„ ì´ë¦„(ì •ê·œí™”) 
const SIDO_NAME_FIX = {
  "11": "ì„œìš¸íŠ¹ë³„ì‹œ",
  "26": "ë¶€ì‚°ê´‘ì—­ì‹œ",
  "27": "ëŒ€êµ¬ê´‘ì—­ì‹œ",
  "28": "ì¸ì²œê´‘ì—­ì‹œ",
  "29": "ê´‘ì£¼ê´‘ì—­ì‹œ",
  "30": "ëŒ€ì „ê´‘ì—­ì‹œ",
  "31": "ìš¸ì‚°ê´‘ì—­ì‹œ",
  "36": "ì„¸ì¢…íŠ¹ë³„ìì¹˜ì‹œ",
  "41": "ê²½ê¸°ë„",
  "42": "ê°•ì›íŠ¹ë³„ìì¹˜ë„", // ì˜› ì½”ë“œ ëŒ€ë¹„
  "43": "ì¶©ì²­ë¶ë„",
  "44": "ì¶©ì²­ë‚¨ë„",
  "45": "ì „ë¶íŠ¹ë³„ìì¹˜ë„", // ì˜› ì½”ë“œ ëŒ€ë¹„
  "46": "ì „ë¼ë‚¨ë„",
  "47": "ê²½ìƒë¶ë„",
  "48": "ê²½ìƒë‚¨ë„",
  "50": "ì œì£¼íŠ¹ë³„ìì¹˜ë„",
  "51": "ê°•ì›íŠ¹ë³„ìì¹˜ë„",
  "52": "ì „ë¶íŠ¹ë³„ìì¹˜ë„",
};

const normalizeSidoName = (feature) => {
  const p = feature?.properties || {};
  const code = String(pick(p, SIDO_CODE_KEYS) || "");
  return SIDO_NAME_FIX[code] || pick(p, SIDO_NAME_KEYS) || "ë¯¸ìƒ ì‹œ/ë„";
};

/*  ì‹œ/ë„ ë¼ë²¨ ì¤‘ì‹¬+ì˜¤í”„ì…‹ */
const SIDO_MANUAL_CENTERS = {
  "11": [37.5665, 126.978],
  "26": [35.1796, 129.0756],
  "27": [35.8714, 128.6014],
  "28": [37.4563, 126.7052],
  "29": [35.1595, 126.8526],
  "30": [36.3504, 127.3845],
  "31": [35.5384, 129.3114],
  "36": [36.48, 127.289],
  "41": [37.4138, 127.5183],
  "42": [37.8228, 128.1555], // ì˜› ê°•ì› ì½”ë“œ
  "43": [36.6357, 127.4917],
  "44": [36.5184, 126.8],
  "45": [35.817, 127.111], // ì˜› ì „ë¶ ì½”ë“œ
  "46": [35.12, 126.9],
  "47": [36.4919, 128.8889],
  "48": [35.23, 128.25],
  "50": [33.4996, 126.5312],
  "51": [37.8228, 128.1555], // ê°•ì›íŠ¹ë³„ìì¹˜ë„(ì‹  ì½”ë“œ)
  "52": [35.817, 127.111], // ì „ë¶íŠ¹ë³„ìì¹˜ë„(ì‹  ì½”ë“œ)
};

const SIDO_OFFSETS = {
  "11": [0.08, -0.1],
  "28": [0.04, -0.08],
  "36": [0.02, 0.08],
  "30": [-0.02, 0.02],
  "41": [0.02, -0.06],
  "43": [0.0, 0.0],
  "44": [0.02, 0.1],
  "45": [0.02, 0.12],
  "46": [0.02, 0.06],
  "47": [0.0, 0.0],
  "48": [0.05, -0.1],
  "26": [0.0, -0.04],
  "27": [0.02, -0.02],
  "31": [0.0, 0.06],
  "42": [0.0, 0.0],
  "50": [0.0, 0.0],
  "51": [0.0, 0.0],
  "52": [0.0, 0.0],
};

const OFFSET_VERSION = Object.entries(SIDO_OFFSETS)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([k, v]) => `${k}:${v[0].toFixed(3)},${v[1].toFixed(3)}`)
  .join("|");

const CENTER_VERSION = Object.entries(SIDO_MANUAL_CENTERS)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([k, v]) => `${k}:${v[0].toFixed(4)},${v[1].toFixed(4)}`)
  .join("|");

function calcCenterLatLng(feature) {
  const code = String(pick(feature.properties, SIDO_CODE_KEYS) || "");
  if (SIDO_MANUAL_CENTERS[code]) {
    const [lat, lng] = SIDO_MANUAL_CENTERS[code];
    return [lat, lng];
  }
  try {
    const pt = centerOfMass(feature);
    const [lng, lat] = pt.geometry.coordinates;
    return [lat, lng];
  } catch {
    return null;
  }
}

//ì—ë„ˆì§€ íˆíŠ¸ì»¬ëŸ¬ (ë²„í‚· ë°©ì‹: íŒŒìŠ¤í…” ë¸”ë£¨ / íŒŒìŠ¤í…” ì˜¤ë Œì§€) 

const NO_DATA_COLOR = "#e0e0e0";

//  ì „ê¸°: íŒŒìŠ¤í…” í•˜ëŠ˜ìƒ‰ â†’ íŒŒìŠ¤í…” ë¸”ë£¨ (5ë‹¨ê³„)
const ELECTRIC_BUCKETS = [
  "#f3f8ff", // í•˜ìœ„ 20%
  "#d9e7ff", // 20~40%
  "#bed4ff", // 40~60%
  "#9cbcff", // 60~80%
  "#7699ff", // ìƒìœ„ 20%
];

//  ê°€ìŠ¤: í¬ë¦¼ â†’ ì‚´êµ¬ â†’ ì˜¤ë Œì§€ (5ë‹¨ê³„)
const GAS_BUCKETS = [
  "#fff7ec", // í•˜ìœ„ 20%
  "#ffe3c4", // 20~40%
  "#ffcd9b", // 40~60%
  "#ffb373", // 60~80%
  "#ff9243", // ìƒìœ„ 20%
];

/*ê°’ ë°°ì—´ì—ì„œ ë¶„ìœ„ìˆ˜(quantile) ìœ„ì¹˜ì˜ ê°’ì„ êµ¬í•˜ëŠ” í—¬í¼ */
const getQuantile = (sortedVals, q) => {
  if (!sortedVals.length) return 0;
  const pos = (sortedVals.length - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  if (sortedVals[base + 1] !== undefined) {
    return sortedVals[base] + (sortedVals[base + 1] - sortedVals[base]) * rest;
  }
  return sortedVals[base];
};

/**
 * ë²„í‚· ê¸°ë°˜ ìƒ‰ ê²°ì •
 * value: í˜„ì¬ ê°’
 * values: ê°™ì€ ë ˆë²¨(ì‹œë„ or ì‹œêµ°êµ¬)ì˜ ëª¨ë“  ê°’ ë°°ì—´
 * type: 'electric' | 'gas'
 */
const getBucketColor = (value, values, type) => {
  if (value == null || isNaN(value) || value <= 0) return NO_DATA_COLOR;
  if (!values || !values.length) return NO_DATA_COLOR;

  const palette = type === "gas" ? GAS_BUCKETS : ELECTRIC_BUCKETS;

  // ê°’ë“¤ ì •ë ¬
  const sorted = [...values].filter((v) => v > 0).sort((a, b) => a - b);
  if (!sorted.length) return NO_DATA_COLOR;

  // ë¶„ìœ„ìˆ˜ ê¸°ì¤€ ê°’ë“¤ (20%, 40%, 60%, 80%)
  const q20 = getQuantile(sorted, 0.2);
  const q40 = getQuantile(sorted, 0.4);
  const q60 = getQuantile(sorted, 0.6);
  const q80 = getQuantile(sorted, 0.8);

  // í˜„ì¬ ê°’ì´ ì–´ëŠ êµ¬ê°„ì— ì†í•˜ëŠ”ì§€ì— ë”°ë¼ ìƒ‰ ì„ íƒ
  if (value <= q20) return palette[0];
  if (value <= q40) return palette[1];
  if (value <= q60) return palette[2];
  if (value <= q80) return palette[3];
  return palette[4]; // ìƒìœ„ 20%
};

const ymToLabel = (ym) => {
  const s = String(ym || "");
  if (s.length !== 6) return s || "â€”";
  return `${s.slice(0, 4)}ë…„ ${s.slice(4)}ì›”`;
};
//ë©”ì¸ ì»´í¬ë„ŒíŠ¸  
export default function MapKorea({
  onRegionSelect,
  allEnergyData, 
  yearMonth = "202506",
  energyType = "electric",          
  onEnergyTypeChange,               
}) {
  const [level, setLevel] = useState("sido"); // 'sido' | 'sgg'
  const [selectedSido, setSelectedSido] = useState(null);
  const [warn, setWarn] = useState("");

  const [sidoFC, setSidoFC] = useState(null); // ì‹œ/ë„ FC
  const [sggAll, setSggAll] = useState(null); // ì „êµ­ SGG FC
  const [sggFC, setSggFC] = useState(null); // ì„ íƒ ì‹œ/ë„ SGG FC

  const [koreaMask, setKoreaMask] = useState(null);
  const [focusMask, setFocusMask] = useState(null);

  const geojsonRef = useRef(null);

  // ë°ì´í„° ë¡œë“œ (public/korea) 
  useEffect(() => {
    (async () => {
      try {
        const r1 = await fetch("/korea/SIDO_MAP_2022.json");
        const sido = await r1.json();
        setSidoFC(sido);
        setKoreaMask(makeMaskFromSidoFC(sido));
      } catch {
        setWarn(" /korea/SIDO_MAP_2022.json ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
      }
      try {
        const r2 = await fetch("/korea/sgg.json");
        const sgg = await r2.json();
        setSggAll(sgg);
      } catch {
        setWarn(
          (w) =>
            (w ? w + " / " : "") + "/korea/sgg.json ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
        );
      }
    })();
  }, []);

 // ì‹œ/ë„ í´ë¦­ â†’ í•´ë‹¹ ì‹œ/ë„ì˜ SGG í•„í„° 
  useEffect(() => {
    if (level !== "sgg") return;
    const code = selectedSido?.code;
    if (!code) {
      setSggFC(null);
      setFocusMask(null);
      return;
    }

    const sidoFeat =
      sidoFC?.features?.find(
        (ft) => String(pick(ft.properties, SIDO_CODE_KEYS)) === String(code)
      ) || null;
    setFocusMask(sidoFeat ? makeMaskFromOneSido(sidoFeat) : null);

    if (sggAll?.features) {
      const feats = sggAll.features.filter((ft) => {
        const p = ft.properties || {};
        let parent = pick(p, PARENT_KEYS);
        if (parent == null) {
          const sig = pick(p, SGG_CODE_KEYS);
          if (sig) parent = String(sig).slice(0, 2);
        }
        return String(parent) === String(code);
      });
      setSggFC(
        feats.length ? { type: "FeatureCollection", features: feats } : null
      );
    } else {
      setSggFC(null);
    }
  }, [level, selectedSido, sggAll, sidoFC]);

  // í˜„ì¬ FC ì„ íƒ 
  const currentFC = useMemo(
    () => (level === "sido" ? sidoFC : sggFC),
    [level, sidoFC, sggFC]
  );

  // ì‹œ/ë„ ë¼ë²¨ ì¢Œí‘œ ì‚¬ì „ ê³„ì‚°(+ì˜¤í”„ì…‹) 
  const sidoLabelCenterByCode = useMemo(() => {
    if (!sidoFC?.features) return {};
    const map = {};
    for (const f of sidoFC.features) {
      const code = String(pick(f.properties, SIDO_CODE_KEYS) || "");
      let ll = calcCenterLatLng(f) || [0, 0];
      const ofs = SIDO_OFFSETS[code];
      if (ofs) ll = [ll[0] + ofs[0], ll[1] + ofs[1]];
      map[code] = ll;
    }
    return map;
  }, [sidoFC, CENTER_VERSION, OFFSET_VERSION]);

  /* ì—ë„ˆì§€ ë°ì´í„° ì „ì²˜ë¦¬  */
  const rawData = Array.isArray(allEnergyData)
    ? allEnergyData
    : allEnergyData?.items || [];

  // í•´ë‹¹ ì›”ë§Œ í•„í„°
  const filtered = useMemo(
    () => rawData.filter((d) => String(d?.yearMonth) === String(yearMonth)),
    [rawData, yearMonth]
  );

  // 1) ì‹œêµ°êµ¬ ì½”ë“œ â†’ ê°’ í•©ê³„ (countyId ê¸°ì¤€, 5ìë¦¬ë¡œ ì •ê·œí™”)
  const sggValueByCode = useMemo(() => {
    const m = {};
    for (const d of filtered) {
      const code = normalizeSggCodeFromData(d?.countyId);
      if (!code) continue;
      const val =
        energyType === "gas" ? Number(d.useGas) : Number(d.useElect);
      if (!isNaN(val) && val > 0) {
        m[code] = (m[code] ?? 0) + val;
      }
    }
    return m;
  }, [filtered, energyType]);

  // 2) ì‹œë„ ì½”ë“œë³„ ê°’ í•©ê³„ = ì‹œêµ°êµ¬ ê°’ë“¤ì„ ì• 2ìë¦¬ë¡œ ë¬¶ì–´ì„œ í•©ì‚°
  const sidoValueByCode = useMemo(() => {
    const m = {};
    Object.entries(sggValueByCode).forEach(([sggCode, val]) => {
      if (!val || val <= 0) return;
      const sidoCode = String(sggCode).slice(0, 2); // 11, 26, 51, 52 ...
      m[sidoCode] = (m[sidoCode] ?? 0) + val;
    });
    return m;
  }, [sggValueByCode]);

  // ë²„í‚· ìƒ‰ ê³„ì‚°ìš© ê°’ ë°°ì—´ (ì‹œë„ ë˜ëŠ” ì‹œêµ°êµ¬)
  const baseValues = useMemo(() => {
    const baseMap = level === "sido" ? sidoValueByCode : sggValueByCode;
    return Object.values(baseMap).filter((v) => v > 0);
  }, [level, sidoValueByCode, sggValueByCode]);

  // ë””ë²„ê·¸ ë¡œê·¸ 
  useEffect(() => {
    console.log("===== [MapKorea] DEBUG =====");
    console.log(
      "yearMonth:",
      yearMonth,
      "energyType:",
      energyType,
      "level:",
      level
    );
    console.log("rawData length:", rawData.length);
    console.log("filtered length:", filtered.length);
    console.log("sidoValue keys:", Object.keys(sidoValueByCode));
    console.log("sggValue keys length:", Object.keys(sggValueByCode).length);
  }, [
    rawData,
    filtered,
    sidoValueByCode,
    sggValueByCode,
    energyType,
    level,
    yearMonth,
  ]);

  //ìŠ¤íƒ€ì¼ (íˆíŠ¸ì»¬ëŸ¬) 
  const styleFn = (feature) => {
    if (level === "sido") {
      const code2 = String(pick(feature.properties, SIDO_CODE_KEYS) || ""); // ì˜ˆ: "51"
      const val = sidoValueByCode[code2];
      return {
        weight: 1,
        color: "#ffffff",
        fillOpacity: 0.92,
        fillColor: getBucketColor(val, baseValues, energyType),
      };
    }
    // SGG
    const code5 = String(pick(feature.properties, SGG_CODE_KEYS) || "");
    const val = sggValueByCode[code5];
    return {
      weight: 1,
      color: "#ffffff",
      fillOpacity: 0.92,
      fillColor: getBucketColor(val, baseValues, energyType),
    };
  };

  /* SGG ì „ì²´ëª…(ì‹œ/ë„ + ì‹œêµ°êµ¬) */
  const sggFullName = (sggFeature) => {
    const sggName =
      pick(sggFeature?.properties || {}, SGG_NAME_KEYS) || "ë¯¸ìƒ ì‹œêµ°êµ¬";
    const sidoName = selectedSido?.name || "ë¯¸ìƒ ì‹œ/ë„";
    return `${sidoName} ${String(sggName).replace(/<br\/>/g, " ")}`;
  };

  /* ë¼ë²¨/íŒì—…/ì´ë²¤íŠ¸ */
  const onEachFeature = (feature, layer) => {
    if (level === "sido") {
      const code = String(pick(feature.properties, SIDO_CODE_KEYS) || "");
      const name = normalizeSidoName(feature);
      const ll = sidoLabelCenterByCode[code];

      if (ll) {
        const tip = L.tooltip({
          permanent: true,
          direction: "center",
          className: "area-label",
        })
          .setContent(name)
          .setLatLng(ll);
        layer.bindTooltip(tip);
        layer.on("add", () => {
          try {
            layer.openTooltip();
          } catch {}
        });
      }

      layer.on("mouseover", (e) => {
        layer.setStyle({ weight: 2, color: "#ffffff" });
        layer
          .bindPopup(`${name}<br/>${ymToLabel(yearMonth)}`)
          .openPopup(e.latlng);
      });
      layer.on("mouseout", () => {
        layer.setStyle({ weight: 1, color: "#ffffff" });
        layer.closePopup();
      });
      layer.on("click", (e) => {
        setSelectedSido({ code, name });
        setLevel("sgg");
        layer
          .bindPopup(`${name}<br/>${ymToLabel(yearMonth)}`)
          .openPopup(e.latlng);
        onRegionSelect?.({ cityId: Number(code), cityName: name });
      });
      layer.on("add", () => {
        try {
          layer.getElement()?.classList?.add("cursor-pointer");
        } catch {}
      });
    } else {
      const name = sggFullName(feature);
      try {
        const pt = centerOfMass(feature);
        const [lng, lat] = pt.geometry.coordinates;
        const tip = L.tooltip({
          permanent: true,
          direction: "center",
          className: "area-label sgg",
        })
          .setContent(name.replace((selectedSido?.name || "") + " ", ""))
          .setLatLng([lat, lng]);
        layer.bindTooltip(tip);
        layer.on("add", () => {
          try {
            layer.openTooltip();
          } catch {}
        });
      } catch {}

      layer.on("mouseover", (e) => {
        layer.setStyle({ weight: 2, color: "#ffffff" });
        layer
          .bindPopup(`${name}<br/>${ymToLabel(yearMonth)}`)
          .openPopup(e.latlng);
      });
      layer.on("mouseout", () => {
        layer.setStyle({ weight: 1, color: "#ffffff" });
        layer.closePopup();
      });
      layer.on("click", (e) => {
        layer
          .bindPopup(`${name}<br/>${ymToLabel(yearMonth)}`)
          .openPopup(e.latlng);
        const sigCd = String(pick(feature.properties, SGG_CODE_KEYS) || "");
        const sigName = pick(feature.properties, SGG_NAME_KEYS);
        onRegionSelect?.({
          cityId: Number(selectedSido?.code),
          countyId: Number(sigCd),
          cityName: selectedSido?.name,
          countyName: sigName,
        });
      });
    }
  };

  const resetToSido = () => {
    setLevel("sido");
    setSelectedSido(null);
    setSggFC(null);
    setFocusMask(null);
    onRegionSelect?.(null); // ğŸ”™ ìƒìœ„(selectedRegion)ë„ ì „êµ­ìœ¼ë¡œ
  };

  return (
    <div className="map-host">
      {/* ìƒë‹¨ íˆ´ë°” */}
      <div className="map-toolbar">
        <div className="month-label">ğŸ“… {ymToLabel(yearMonth)} ê¸°ì¤€</div>
        <div className="map-energy-buttons">
          <button
            className={energyType === "electric" ? "active-electric" : ""}
            onClick={() => onEnergyTypeChange?.("electric")}
            title="ì „ê¸° ì‚¬ìš©ëŸ‰ ë³´ê¸°"
          >
            âš¡ ì „ê¸°
          </button>
          <button
            className={energyType === "gas" ? "active-gas" : ""}
            onClick={() => onEnergyTypeChange?.("gas")}
            title="ê°€ìŠ¤ ì‚¬ìš©ëŸ‰ ë³´ê¸°"
          >
            ğŸ”¥ ê°€ìŠ¤
          </button>
        </div>
      </div>

      {warn && <div className="warn-box">{warn}</div>}

      {level === "sgg" && (
        <button className="btn-back" onClick={resetToSido}>
          â—€ ì‹œ/ë„ë¡œ ëŒì•„ê°€ê¸°
        </button>
      )}

      <MapContainer
        key={
          level === "sido"
            ? `map-sido-${CENTER_VERSION}-${OFFSET_VERSION}`
            : `map-sgg-${selectedSido?.code || ""}`
        }
        bounds={KOREA_BOUNDS}
        minZoom={6}
        maxZoom={13}
        maxBounds={KOREA_BOUNDS}
        maxBoundsViscosity={1.0}
        inertia={false}
        worldCopyJump={false}
        zoomControl={false}
        attributionControl={false}
        zoomSnap={0.25}
        zoomDelta={0.25}
        wheelPxPerZoomLevel={220}
        wheelDebounceTime={40}
        style={{ height: "100%", width: "100%" }}
      >
        <Pane name="mask" style={{ zIndex: 400 }} />
        <Pane name="gaps" style={{ zIndex: 405 }} />
        <Pane name="polygons" style={{ zIndex: 410 }} />

        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          noWrap
        />

        {(level === "sgg" ? focusMask : koreaMask) && (
          <GeoJSON
            pane="mask"
            data={level === "sgg" ? focusMask : koreaMask}
            style={{
              fillColor: "#ffffffff",
              fillOpacity: 0.6,
              color: "#0b1020",
              weight: 0,
            }}
            interactive={false}
          />
        )}

        {currentFC && (
          <GeoJSON
            pane="gaps"
            data={currentFC}
            style={{
              fillOpacity: 0,
              color: "#ebdfd8ff",
              weight: level === "sido" ? 6 : 3,
              lineJoin: "round",
              lineCap: "round",
            }}
            interactive={false}
          />
        )}

        {currentFC && (
          <GeoJSON
            key={
              level === "sido"
                ? `polygons-sido-${CENTER_VERSION}-${OFFSET_VERSION}`
                : `polygons-sgg-${selectedSido?.code || ""}`
            }
            pane="polygons"
            ref={geojsonRef}
            data={currentFC}
            style={styleFn}
            onEachFeature={onEachFeature}
          />
        )}

        <FitToLayer
          targetRef={geojsonRef}
          deps={[
            level,
            selectedSido?.code,
            currentFC?.features?.length,
            CENTER_VERSION,
            OFFSET_VERSION,
            energyType,
            yearMonth,
          ]}
        />
        <ClampToKorea />
      </MapContainer>
    </div>
  );
}
