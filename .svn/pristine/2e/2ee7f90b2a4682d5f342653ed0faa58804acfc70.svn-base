// src/components/MapKorea.jsx
// ëŒ€í•œë¯¼êµ­ ì½”ë¡œí”Œë ˆìŠ¤ ì§€ë„ â€” ì‹œ/ë„ â†’ ì‹œÂ·êµ°Â·êµ¬ ë“œë¦´ë‹¤ìš´ + ì—ë„ˆì§€ íˆíŠ¸ì»¬ëŸ¬(ì „ê¸°/ê°€ìŠ¤ í† ê¸€)

import { useEffect, useMemo, useRef, useState } from "react";
import {
  MapContainer,
  TileLayer,
  GeoJSON,
  Pane,
  useMap,
  useMapEvent,
} from "react-leaflet";
import L from "leaflet";
import centerOfMass from "@turf/center-of-mass";
import "leaflet/dist/leaflet.css";
import "./MapKorea.css";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ í‚¤/ìœ í‹¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const SIDO_CODE_KEYS = ["CTPRVN_CD", "CTPRV_CD", "CTP_CD", "SIDO_CD", "SIG_CD"];
const SIDO_NAME_KEYS = ["CTP_KOR_NM", "SIDO_NM", "CTP_ENG_NM", "CTP_NM"];
const SGG_CODE_KEYS = ["SIG_CD", "SGG_CD", "ADM_DR_CD"];
const SGG_NAME_KEYS = ["SIG_KOR_NM", "SGG_NM", "ADM_DR_NM", "SIG_NM"];
const PARENT_KEYS = ["CTPRVN_CD", "UPPER_CD", "SIDO_CD"];
const pick = (o, keys) => {
  for (const k of keys) if (o && o[k] != null) return o[k];
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë·°í¬íŠ¸/í´ë¨í”„ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const KOREA_BOUNDS = [
  [32.5, 124.0],
  [39.6, 132.5],
];
function ClampToKorea() {
  const map = useMap();
  useEffect(() => {
    map.options.inertia = false;
  }, [map]);
  const clamp = () => {
    if (!map.getBounds().intersects(KOREA_BOUNDS)) {
      map.panInsideBounds(KOREA_BOUNDS, { animate: false });
    }
  };
  useMapEvent("move", clamp);
  useMapEvent("zoom", clamp);
  useMapEvent("moveend", clamp);
  return null;
}
function useFitBounds(geojsonRef, deps = []) {
  const map = useMap();
  useEffect(() => {
    const layer = geojsonRef.current;
    if (!layer) return;
    try {
      const b = layer.getBounds();
      if (b && b.isValid()) {
        const s = Math.max(b.getSouth(), KOREA_BOUNDS[0][0]);
        const w = Math.max(b.getWest(), KOREA_BOUNDS[0][1]);
        const n = Math.min(b.getNorth(), KOREA_BOUNDS[1][0]);
        const e = Math.min(b.getEast(), KOREA_BOUNDS[1][1]);
        map.fitBounds(
          [
            [s, w],
            [n, e],
          ],
          { padding: [24, 24], paddingBottomRight: [24, 80] }
        );
      }
    } catch {}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
}
function FitToLayer({ targetRef, deps }) {
  useFitBounds(targetRef, deps);
  return null;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë§ˆìŠ¤í¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const WORLD_RING = [
  [-180, -90],
  [-180, 90],
  [180, 90],
  [180, -90],
  [-180, -90],
];
const ringsFromGeom = (g) =>
  !g
    ? []
    : g.type === "Polygon"
    ? g.coordinates
    : g.type === "MultiPolygon"
    ? g.coordinates.flat()
    : [];
const makeMaskFromSidoFC = (fc) => {
  if (!fc?.features) return null;
  const holes = [];
  for (const f of fc.features) holes.push(...ringsFromGeom(f.geometry));
  return {
    type: "Feature",
    properties: { kind: "mask-korea" },
    geometry: { type: "Polygon", coordinates: [WORLD_RING, ...holes] },
  };
};
const makeMaskFromOneSido = (f) => {
  if (!f?.geometry) return null;
  const holes = ringsFromGeom(f.geometry);
  return {
    type: "Feature",
    properties: { kind: "mask-sido" },
    geometry: { type: "Polygon", coordinates: [WORLD_RING, ...holes] },
  };
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì‹œ/ë„ ì´ë¦„(ì •ê·œí™”) â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const SIDO_NAME_FIX = {
  "11": "ì„œìš¸íŠ¹ë³„ì‹œ",
  "26": "ë¶€ì‚°ê´‘ì—­ì‹œ",
  "27": "ëŒ€êµ¬ê´‘ì—­ì‹œ",
  "28": "ì¸ì²œê´‘ì—­ì‹œ",
  "29": "ê´‘ì£¼ê´‘ì—­ì‹œ",
  "30": "ëŒ€ì „ê´‘ì—­ì‹œ",
  "31": "ìš¸ì‚°ê´‘ì—­ì‹œ",
  "36": "ì„¸ì¢…íŠ¹ë³„ìì¹˜ì‹œ",
  "41": "ê²½ê¸°ë„",
  "42": "ê°•ì›íŠ¹ë³„ìì¹˜ë„",
  "43": "ì¶©ì²­ë¶ë„",
  "44": "ì¶©ì²­ë‚¨ë„",
  "45": "ì „ë¶íŠ¹ë³„ìì¹˜ë„",
  "46": "ì „ë¼ë‚¨ë„",
  "47": "ê²½ìƒë¶ë„",
  "48": "ê²½ìƒë‚¨ë„",
  "50": "ì œì£¼íŠ¹ë³„ìì¹˜ë„",
};
const normalizeSidoName = (feature) => {
  const p = feature?.properties || {};
  const code = String(pick(p, SIDO_CODE_KEYS) || "");
  return SIDO_NAME_FIX[code] || pick(p, SIDO_NAME_KEYS) || "ë¯¸ìƒ ì‹œ/ë„";
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì‹œ/ë„ ë¼ë²¨ ì¤‘ì‹¬+ì˜¤í”„ì…‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const SIDO_MANUAL_CENTERS = {
  "11": [37.5665, 126.978],
  "26": [35.1796, 129.0756],
  "27": [35.8714, 128.6014],
  "28": [37.4563, 126.7052],
  "29": [35.1595, 126.8526],
  "30": [36.3504, 127.3845],
  "31": [35.5384, 129.3114],
  "36": [36.48, 127.289],
  "41": [37.4138, 127.5183],
  "42": [37.8228, 128.1555],
  "43": [36.6357, 127.4917],
  "44": [36.5184, 126.8],
  "45": [35.817, 127.111],
  "46": [35.12, 126.9],
  "47": [36.4919, 128.8889],
  "48": [35.23, 128.25],
  "50": [33.4996, 126.5312],
};
const SIDO_OFFSETS = {
  "11": [0.08, -0.1],
  "28": [0.04, -0.08],
  "36": [0.02, 0.08],
  "30": [-0.02, 0.02],
  "41": [0.02, -0.06],
  "43": [0.0, 0.0],
  "44": [0.02, 0.1],
  "45": [0.02, 0.12],
  "46": [0.02, 0.06],
  "47": [0.0, 0.0],
  "48": [0.05, -0.1],
  "26": [0.0, -0.04],
  "27": [0.02, -0.02],
  "31": [0.0, 0.06],
  "42": [0.0, 0.0],
  "50": [0.0, 0.0],
};
const OFFSET_VERSION = Object.entries(SIDO_OFFSETS)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([k, v]) => `${k}:${v[0].toFixed(3)},${v[1].toFixed(3)}`)
  .join("|");
const CENTER_VERSION = Object.entries(SIDO_MANUAL_CENTERS)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([k, v]) => `${k}:${v[0].toFixed(4)},${v[1].toFixed(4)}`)
  .join("|");

function calcCenterLatLng(feature) {
  const code = String(pick(feature.properties, SIDO_CODE_KEYS) || "");
  if (SIDO_MANUAL_CENTERS[code]) {
    const [lat, lng] = SIDO_MANUAL_CENTERS[code];
    return [lat, lng];
  }
  try {
    const pt = centerOfMass(feature);
    const [lng, lat] = pt.geometry.coordinates;
    return [lat, lng];
  } catch {
    return null;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì—ë„ˆì§€ íˆíŠ¸ì»¬ëŸ¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const getColorScale = (value, min, max, type) => {
  if (value == null || isNaN(value)) return "#e6e6e6";
  const ratio = Math.pow((value - min) / (max - min + 1e-6), 0.6);
  if (type === "electric") {
    const r = Math.round(180 - ratio * 160);
    const g = Math.round(210 - ratio * 190);
    const b = Math.round(255 - ratio * 100);
    return `rgb(${r},${g},${b})`;
  } else {
    const r = Math.round(255 - ratio * 60);
    const g = Math.round(210 - ratio * 160);
    const b = Math.round(130 - ratio * 100);
    return `rgb(${r},${g},${b})`;
  }
};
const ymToLabel = (ym) => {
  const s = String(ym || "");
  if (s.length !== 6) return s || "â€”";
  return `${s.slice(0, 4)}ë…„ ${s.slice(4)}ì›”`;
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë©”ì¸ ì»´í¬ë„ŒíŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export default function MapKorea({
  onRegionSelect,
  allEnergyData, // [{yearMonth, cityId, countyId, useElect, useGas}, ...] or {items:[...]}
  yearMonth = "202506",
}) {
  const [level, setLevel] = useState("sido"); // 'sido' | 'sgg'
  const [selectedSido, setSelectedSido] = useState(null);
  const [warn, setWarn] = useState("");

  const [sidoFC, setSidoFC] = useState(null); // ì‹œ/ë„ FC
  const [sggAll, setSggAll] = useState(null); // ì „êµ­ SGG FC
  const [sggFC, setSggFC] = useState(null); // ì„ íƒ ì‹œ/ë„ SGG FC

  const [koreaMask, setKoreaMask] = useState(null);
  const [focusMask, setFocusMask] = useState(null);

  const [energyType, setEnergyType] = useState("electric"); // ì „ê¸°/ê°€ìŠ¤
  const geojsonRef = useRef(null);

  /* ë°ì´í„° ë¡œë“œ (public/korea) */
  useEffect(() => {
    (async () => {
      try {
        const r1 = await fetch("/korea/SIDO_MAP_2022.json");
        const sido = await r1.json();
        setSidoFC(sido);
        setKoreaMask(makeMaskFromSidoFC(sido));
      } catch {
        setWarn("â— /korea/SIDO_MAP_2022.json ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
      }
      try {
        const r2 = await fetch("/korea/sgg.json");
        const sgg = await r2.json();
        setSggAll(sgg);
      } catch {
        setWarn(
          (w) => (w ? w + " / " : "") + "â— /korea/sgg.json ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
        );
      }
    })();
  }, []);

  /* ì‹œ/ë„ í´ë¦­ â†’ í•´ë‹¹ ì‹œ/ë„ì˜ SGG í•„í„° */
  useEffect(() => {
    if (level !== "sgg") return;
    const code = selectedSido?.code;
    if (!code) {
      setSggFC(null);
      setFocusMask(null);
      return;
    }

    const sidoFeat =
      sidoFC?.features?.find(
        (ft) => String(pick(ft.properties, SIDO_CODE_KEYS)) === String(code)
      ) || null;
    setFocusMask(sidoFeat ? makeMaskFromOneSido(sidoFeat) : null);

    if (sggAll?.features) {
      const feats = sggAll.features.filter((ft) => {
        const p = ft.properties || {};
        let parent = pick(p, PARENT_KEYS);
        if (parent == null) {
          const sig = pick(p, SGG_CODE_KEYS);
          if (sig) parent = String(sig).slice(0, 2);
        }
        return String(parent) === String(code);
      });
      setSggFC(
        feats.length ? { type: "FeatureCollection", features: feats } : null
      );
    } else {
      setSggFC(null);
    }
  }, [level, selectedSido, sggAll, sidoFC]);

  /* í˜„ì¬ FC ì„ íƒ */
  const currentFC = useMemo(
    () => (level === "sido" ? sidoFC : sggFC),
    [level, sidoFC, sggFC]
  );

  /* ì‹œ/ë„ ë¼ë²¨ ì¢Œí‘œ ì‚¬ì „ ê³„ì‚°(+ì˜¤í”„ì…‹) */
  const sidoLabelCenterByCode = useMemo(() => {
    if (!sidoFC?.features) return {};
    const map = {};
    for (const f of sidoFC.features) {
      const code = String(pick(f.properties, SIDO_CODE_KEYS) || "");
      let ll = calcCenterLatLng(f) || [0, 0];
      const ofs = SIDO_OFFSETS[code];
      if (ofs) ll = [ll[0] + ofs[0], ll[1] + ofs[1]];
      map[code] = ll;
    }
    return map;
  }, [sidoFC, CENTER_VERSION, OFFSET_VERSION]);

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì—ë„ˆì§€ ë°ì´í„° ì „ì²˜ë¦¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const rawData = Array.isArray(allEnergyData)
    ? allEnergyData
    : allEnergyData?.items || [];

  // í•´ë‹¹ ì›”ë§Œ í•„í„°
  const filtered = useMemo(
    () => rawData.filter((d) => String(d?.yearMonth) === String(yearMonth)),
    [rawData, yearMonth]
  );

  // ì‹œêµ°êµ¬ ì½”ë“œ â†’ ê°’ í•©ê³„
  const sggValueByCode = useMemo(() => {
    const m = {};
    for (const d of filtered) {
      const code = d?.countyId != null ? String(d.countyId) : null;
      if (!code) continue;
      const val =
        energyType === "gas" ? Number(d.useGas) : Number(d.useElect);
      if (!isNaN(val)) m[code] = (m[code] ?? 0) + val;
    }
    return m;
  }, [filtered, energyType]);

  // ì‹œë„ ì½”ë“œ(2ìë¦¬) â†’ í•©ê³„ (cityId ìš°ì„ , ì—†ìœ¼ë©´ countyId ì• 2ìë¦¬)
  const sidoValueByCode = useMemo(() => {
    const m = {};
    for (const d of filtered) {
      let s2 = null;
      if (d?.cityId != null) s2 = String(d.cityId).padStart(2, "0");
      else if (d?.countyId != null) s2 = String(d.countyId).slice(0, 2);
      if (!s2) continue;
      const val =
        energyType === "gas" ? Number(d.useGas) : Number(d.useElect);
      if (!isNaN(val)) m[s2] = (m[s2] ?? 0) + val;
    }
    return m;
  }, [filtered, energyType]);

  // min/max (ë ˆë²¨ë³„ë¡œ)
  const { minVal, maxVal } = useMemo(() => {
    const vals = Object.values(
      level === "sido" ? sidoValueByCode : sggValueByCode
    ).filter((v) => v > 0);
    return vals.length
      ? { minVal: Math.min(...vals), maxVal: Math.max(...vals) }
      : { minVal: 0, maxVal: 0 };
  }, [level, sidoValueByCode, sggValueByCode]);

  /* ìŠ¤íƒ€ì¼ (íˆíŠ¸ì»¬ëŸ¬) */
  const styleFn = (feature) => {
    if (level === "sido") {
      const code2 = String(pick(feature.properties, SIDO_CODE_KEYS) || ""); // e.g. "41"
      const val = sidoValueByCode[code2];
      return {
        weight: 1,
        color: "#fff",
        fillOpacity: 0.92,
        fillColor: getColorScale(val, minVal, maxVal, energyType),
      };
    }
    // SGG
    const code5 = String(pick(feature.properties, SGG_CODE_KEYS) || "");
    const val = sggValueByCode[code5];
    return {
      weight: 1,
      color: "#fff",
      fillOpacity: 0.92,
      fillColor: getColorScale(val, minVal, maxVal, energyType),
    };
  };

  /* SGG ì „ì²´ëª…(ì‹œ/ë„ + ì‹œêµ°êµ¬) */
  const sggFullName = (sggFeature) => {
    const sggName =
      pick(sggFeature?.properties || {}, SGG_NAME_KEYS) || "ë¯¸ìƒ ì‹œêµ°êµ¬";
    const sidoName = selectedSido?.name || "ë¯¸ìƒ ì‹œ/ë„";
    return `${sidoName} ${String(sggName).replace(/<br\/>/g, " ")}`;
  };

  /* ë¼ë²¨/íŒì—…/ì´ë²¤íŠ¸ */
  const onEachFeature = (feature, layer) => {
    if (level === "sido") {
      const code = String(pick(feature.properties, SIDO_CODE_KEYS) || "");
      const name = normalizeSidoName(feature);
      const ll = sidoLabelCenterByCode[code];

      if (ll) {
        const tip = L.tooltip({
          permanent: true,
          direction: "center",
          className: "area-label",
        })
          .setContent(name)
          .setLatLng(ll);
        layer.bindTooltip(tip);
        layer.on("add", () => {
          try {
            layer.openTooltip();
          } catch {}
        });
      }

      layer.on("mouseover", (e) => {
        layer.setStyle({ weight: 2, color: "#fff" });
        layer.bindPopup(`${name}<br/>${ymToLabel(yearMonth)}`).openPopup(e.latlng);
      });
      layer.on("mouseout", () => {
        layer.setStyle({ weight: 1, color: "#fff" });
        layer.closePopup();
      });
      layer.on("click", (e) => {
        setSelectedSido({ code, name });
        setLevel("sgg");
        layer
          .bindPopup(`${name}<br/>${ymToLabel(yearMonth)}`)
          .openPopup(e.latlng);
        onRegionSelect?.({ cityId: Number(code), cityName: name });
      });
      layer.on("add", () => {
        try {
          layer.getElement()?.classList?.add("cursor-pointer");
        } catch {}
      });
    } else {
      const name = sggFullName(feature);
      try {
        const pt = centerOfMass(feature);
        const [lng, lat] = pt.geometry.coordinates;
        const tip = L.tooltip({
          permanent: true,
          direction: "center",
          className: "area-label sgg",
        })
          .setContent(name.replace((selectedSido?.name || "") + " ", ""))
          .setLatLng([lat, lng]);
        layer.bindTooltip(tip);
        layer.on("add", () => {
          try {
            layer.openTooltip();
          } catch {}
        });
      } catch {}

      layer.on("mouseover", (e) => {
        layer.setStyle({ weight: 2, color: "#fff" });
        layer.bindPopup(`${name}<br/>${ymToLabel(yearMonth)}`).openPopup(e.latlng);
      });
      layer.on("mouseout", () => {
        layer.setStyle({ weight: 1, color: "#fff" });
        layer.closePopup();
      });
      layer.on("click", (e) => {
        layer
          .bindPopup(`${name}<br/>${ymToLabel(yearMonth)}`)
          .openPopup(e.latlng);
        const sigCd = String(pick(feature.properties, SGG_CODE_KEYS) || "");
        const sigName = pick(feature.properties, SGG_NAME_KEYS);
        onRegionSelect?.({
          cityId: Number(selectedSido?.code),
          countyId: Number(sigCd),
          cityName: selectedSido?.name,
          countyName: sigName,
        });
      });
    }
  };

  const resetToSido = () => {
    setLevel("sido");
    setSelectedSido(null);
    setSggFC(null);
    setFocusMask(null);
  };

  return (
    <div className="map-host">
      {/* âœ… ìƒë‹¨ íˆ´ë°” */}
      <div className="map-toolbar">
        <div className="month-label">ğŸ“… {ymToLabel(yearMonth)} ê¸°ì¤€</div>
        <div className="map-energy-buttons">
          <button
            className={energyType === "electric" ? "active-electric" : ""}
            onClick={() => setEnergyType("electric")}
            title="ì „ê¸° ì‚¬ìš©ëŸ‰ ë³´ê¸°"
          >
            âš¡ ì „ê¸°
          </button>
          <button
            className={energyType === "gas" ? "active-gas" : ""}
            onClick={() => setEnergyType("gas")}
            title="ê°€ìŠ¤ ì‚¬ìš©ëŸ‰ ë³´ê¸°"
          >
            ğŸ”¥ ê°€ìŠ¤
          </button>
        </div>
      </div>

      {warn && <div className="warn-box">{warn}</div>}

      {level === "sgg" && (
        <button className="btn-back" onClick={resetToSido}>
          â—€ ì‹œ/ë„ë¡œ ëŒì•„ê°€ê¸°
        </button>
      )}

      <MapContainer
        key={
          level === "sido"
            ? `map-sido-${CENTER_VERSION}-${OFFSET_VERSION}`
            : `map-sgg-${selectedSido?.code || ""}`
        }
        bounds={KOREA_BOUNDS}
        minZoom={6}
        maxZoom={13}
        maxBounds={KOREA_BOUNDS}
        maxBoundsViscosity={1.0}
        inertia={false}
        worldCopyJump={false}
        zoomControl={false}
        attributionControl={false}
        zoomSnap={0.25}
        zoomDelta={0.25}
        wheelPxPerZoomLevel={220}
        wheelDebounceTime={40}
        style={{ height: "100%", width: "100%" }}
      >
        <Pane name="mask" style={{ zIndex: 400 }} />
        <Pane name="gaps" style={{ zIndex: 405 }} />
        <Pane name="polygons" style={{ zIndex: 410 }} />

        <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" noWrap />

        {(level === "sgg" ? focusMask : koreaMask) && (
          <GeoJSON
            pane="mask"
            data={level === "sgg" ? focusMask : koreaMask}
            style={{
              fillColor: "#ffffffff",
              fillOpacity: 0.6,
              color: "#0b1020",
              weight: 0,
            }}
            interactive={false}
          />
        )}

        {currentFC && (
          <GeoJSON
            pane="gaps"
            data={currentFC}
            style={{
              fillOpacity: 0,
              color: "#ebdfd8ff",
              weight: level === "sido" ? 6 : 3,
              lineJoin: "round",
              lineCap: "round",
            }}
            interactive={false}
          />
        )}

        {currentFC && (
          <GeoJSON
            key={
              level === "sido"
                ? `polygons-sido-${CENTER_VERSION}-${OFFSET_VERSION}`
                : `polygons-sgg-${selectedSido?.code || ""}`
            }
            pane="polygons"
            ref={geojsonRef}
            data={currentFC}
            style={styleFn}
            onEachFeature={onEachFeature}
          />
        )}

        <FitToLayer
          targetRef={geojsonRef}
          deps={[
            level,
            selectedSido?.code,
            currentFC?.features?.length,
            CENTER_VERSION,
            OFFSET_VERSION,
            energyType,
            yearMonth,
          ]}
        />
        <ClampToKorea />
      </MapContainer>
    </div>
  );
}
